{"ast":null,"code":"// See also: https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nimport { useState, useEffect, useRef } from \"react\";\nimport { useWarningOnMountInDevelopment } from \"./useWarningOnMountInDevelopment\";\n/**\n *\n * useInterval hook\n *\n * Declaratively creates a setInterval to run a callback after a fixed\n * amount of time\n *\n *@param {funnction} callback - Callback to be fired\n *@param {number} intervalId - Interval duration in milliseconds after which the callback is to be fired\n *@param {boolean} startImmediate - Whether the interval should start immediately on initialise\n *@returns {IntervalHandler}\n */\n\nfunction useInterval(callback, intervalDuration, startImmediate) {\n  if (startImmediate === void 0) {\n    startImmediate = false;\n  }\n\n  useWarningOnMountInDevelopment(\"useInterval is deprecated, it will be removed in rooks v7. Please use useIntervalWhen instead.\");\n  var internalIdRef = useRef(null);\n\n  var _a = useState(startImmediate),\n      isRunning = _a[0],\n      setIsRunning = _a[1];\n\n  var savedCallback = useRef();\n\n  function start() {\n    if (!isRunning) {\n      setIsRunning(true);\n    }\n  }\n\n  function stop() {\n    if (isRunning) {\n      setIsRunning(false);\n    }\n  } // Remember the latest callback.\n\n\n  useEffect(function () {\n    savedCallback.current = callback;\n  }); // Set up the interval.\n\n  useEffect(function () {\n    function tick() {\n      savedCallback.current && savedCallback.current();\n    }\n\n    if (intervalDuration !== null && isRunning) {\n      var id_1 = setInterval(tick, intervalDuration);\n      internalIdRef.current = id_1;\n      return function () {\n        internalIdRef.current = null;\n        clearInterval(id_1);\n      };\n    }\n  }, [intervalDuration, isRunning]);\n  var handler;\n  handler = [start, stop, internalIdRef.current];\n  handler.start = start;\n  handler.stop = stop;\n  handler.intervalId = internalIdRef.current;\n  return handler;\n}\n\nexport { useInterval };","map":{"version":3,"names":["useState","useEffect","useRef","useWarningOnMountInDevelopment","useInterval","callback","intervalDuration","startImmediate","internalIdRef","_a","isRunning","setIsRunning","savedCallback","start","stop","current","tick","id_1","setInterval","clearInterval","handler","intervalId"],"sources":["C:/Users/ASUS/Desktop/ReactRouter2/ReactRouter/node_modules/rooks/dist/esm/hooks/useInterval.js"],"sourcesContent":["// See also: https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nimport { useState, useEffect, useRef } from \"react\";\nimport { useWarningOnMountInDevelopment } from \"./useWarningOnMountInDevelopment\";\n/**\n *\n * useInterval hook\n *\n * Declaratively creates a setInterval to run a callback after a fixed\n * amount of time\n *\n *@param {funnction} callback - Callback to be fired\n *@param {number} intervalId - Interval duration in milliseconds after which the callback is to be fired\n *@param {boolean} startImmediate - Whether the interval should start immediately on initialise\n *@returns {IntervalHandler}\n */\nfunction useInterval(callback, intervalDuration, startImmediate) {\n    if (startImmediate === void 0) { startImmediate = false; }\n    useWarningOnMountInDevelopment(\"useInterval is deprecated, it will be removed in rooks v7. Please use useIntervalWhen instead.\");\n    var internalIdRef = useRef(null);\n    var _a = useState(startImmediate), isRunning = _a[0], setIsRunning = _a[1];\n    var savedCallback = useRef();\n    function start() {\n        if (!isRunning) {\n            setIsRunning(true);\n        }\n    }\n    function stop() {\n        if (isRunning) {\n            setIsRunning(false);\n        }\n    }\n    // Remember the latest callback.\n    useEffect(function () {\n        savedCallback.current = callback;\n    });\n    // Set up the interval.\n    useEffect(function () {\n        function tick() {\n            savedCallback.current && savedCallback.current();\n        }\n        if (intervalDuration !== null && isRunning) {\n            var id_1 = setInterval(tick, intervalDuration);\n            internalIdRef.current = id_1;\n            return function () {\n                internalIdRef.current = null;\n                clearInterval(id_1);\n            };\n        }\n    }, [intervalDuration, isRunning]);\n    var handler;\n    handler = [start, stop, internalIdRef.current];\n    handler.start = start;\n    handler.stop = stop;\n    handler.intervalId = internalIdRef.current;\n    return handler;\n}\nexport { useInterval };\n"],"mappings":"AAAA;AACA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,MAA9B,QAA4C,OAA5C;AACA,SAASC,8BAAT,QAA+C,kCAA/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CAAqBC,QAArB,EAA+BC,gBAA/B,EAAiDC,cAAjD,EAAiE;EAC7D,IAAIA,cAAc,KAAK,KAAK,CAA5B,EAA+B;IAAEA,cAAc,GAAG,KAAjB;EAAyB;;EAC1DJ,8BAA8B,CAAC,gGAAD,CAA9B;EACA,IAAIK,aAAa,GAAGN,MAAM,CAAC,IAAD,CAA1B;;EACA,IAAIO,EAAE,GAAGT,QAAQ,CAACO,cAAD,CAAjB;EAAA,IAAmCG,SAAS,GAAGD,EAAE,CAAC,CAAD,CAAjD;EAAA,IAAsDE,YAAY,GAAGF,EAAE,CAAC,CAAD,CAAvE;;EACA,IAAIG,aAAa,GAAGV,MAAM,EAA1B;;EACA,SAASW,KAAT,GAAiB;IACb,IAAI,CAACH,SAAL,EAAgB;MACZC,YAAY,CAAC,IAAD,CAAZ;IACH;EACJ;;EACD,SAASG,IAAT,GAAgB;IACZ,IAAIJ,SAAJ,EAAe;MACXC,YAAY,CAAC,KAAD,CAAZ;IACH;EACJ,CAf4D,CAgB7D;;;EACAV,SAAS,CAAC,YAAY;IAClBW,aAAa,CAACG,OAAd,GAAwBV,QAAxB;EACH,CAFQ,CAAT,CAjB6D,CAoB7D;;EACAJ,SAAS,CAAC,YAAY;IAClB,SAASe,IAAT,GAAgB;MACZJ,aAAa,CAACG,OAAd,IAAyBH,aAAa,CAACG,OAAd,EAAzB;IACH;;IACD,IAAIT,gBAAgB,KAAK,IAArB,IAA6BI,SAAjC,EAA4C;MACxC,IAAIO,IAAI,GAAGC,WAAW,CAACF,IAAD,EAAOV,gBAAP,CAAtB;MACAE,aAAa,CAACO,OAAd,GAAwBE,IAAxB;MACA,OAAO,YAAY;QACfT,aAAa,CAACO,OAAd,GAAwB,IAAxB;QACAI,aAAa,CAACF,IAAD,CAAb;MACH,CAHD;IAIH;EACJ,CAZQ,EAYN,CAACX,gBAAD,EAAmBI,SAAnB,CAZM,CAAT;EAaA,IAAIU,OAAJ;EACAA,OAAO,GAAG,CAACP,KAAD,EAAQC,IAAR,EAAcN,aAAa,CAACO,OAA5B,CAAV;EACAK,OAAO,CAACP,KAAR,GAAgBA,KAAhB;EACAO,OAAO,CAACN,IAAR,GAAeA,IAAf;EACAM,OAAO,CAACC,UAAR,GAAqBb,aAAa,CAACO,OAAnC;EACA,OAAOK,OAAP;AACH;;AACD,SAAShB,WAAT"},"metadata":{},"sourceType":"module"}